#!/usr/bin/perl

use strict;

use Getopt::Long;

use DBI;
use DBD::Oracle;

my ($sourceDbConfig, $workflowDbConfig, $needsSubmitFile, $needsDeleteFile, $workflowName, $workflowVersion, $orgAbbrev);

&GetOptions('sourceDbConfig=s' => \$sourceDbConfig,
	    'workflowDbConfig=s' => \$workflowDbConfig,
            'deletesOutputFile=s' => \$needsDeleteFile,
            'submitsOutputFile=s' => \$needsSubmitFile,
            'workflowName=s' => \$workflowName,
            'workflowVersion=s' => \$workflowVersion,
            'organismAbbrev:s' => \$orgAbbrev,  # optional
            );

usage() unless ($sourceDbConfig && $workflowDbConfig && $needsSubmitFile && $needsDeleteFile && $workflowName && $workflowVersion);

my $sourceProps = readPropFile($sourceDbConfig);
my $workflowProps = readPropFile($workflowDbConfig);

my $sourceDbh = getDbHandle($sourceProps);
my $workflowDbh = getDbHandle($workflowProps);

# read into memory the list of sourceDb tuning tables and their timestamp.
my $tuningMap = getAllTuningTablesAndViews($sourceDbh, $sourceProps->{dbVendor});  # hash from tuning name to timestamp

# get stmt to query all artifacts in workflowDb
my $workflowStmt = getWorkflowStmt($workflowDbh, $workflowName, $workflowVersion, $orgAbbrev);

open my $deleteFh, '>', $needsDeleteFile or die "Unable to open file '$needsDeleteFile': $!";
open my $submitFh, '>', $needsSubmitFile or die "Unable to open file '$needsSubmitFile': $!";

$workflowStmt->execute();

# iterate through VDI artifacts from workflowDb and compare to tuning tables in sourceDb
# write to needsDelete or needsSumbit accordingly
while (my ($name, $timestamp, $isComplete) = $workflowStmt->fetchrow_array) {
  if (!$tuningMap->{$name}) {
    # if not in tuningMap, push to delete file
    print $deleteFh "$name\n";
  } else {
    # if older than tuningMap, or not complete, add to submit file
    print $submitFh "$name, $timestamp\n" if $timestamp < $tuningMap->{$name} || !$isComplete;
    $tuningMap->{name} = undef;   # remove because we found it
  }
}

# any entries left in tuningMap are new and need to be submitted
foreach my $name (keys %$tuningMap) {
  print $submitFh "$name, $tuningMap->{$name}\n";
}

#############################################################################################################
#############################################################################################################

sub usage {

  die "
Compare tuning tables in a postgres database (sourceDB) with artifacts in VDI representing those tables, as tracked in an oracle database (workflowDB).  Output files indicating which artifacts are missing, out of date or obsolete.

Usage: tuningTablesComparedToVdi --sourceDbConfig file --workflowDbConfig file --deletesOutputFile file --submitsOutputFile file --workflowName name --workflowVersion version <--organismAbbrev orgAbbrev>

Where:
 -sourceDBconfig: a properties file with gus.config style db connect infor for sourceDB
 -workflowDbConfig: a properties file with gus.config style db connect infor for workflowDB
 -deletesOutputFile:  an output .csv file with a single column list of (tuning_name) to indicate out-of-date tuning tables or views that need to be deleted from VDI
 -submitsOutputFile:  an output .csv file with a two column list of (tuning_name,timestamp) to indicate tuning tables or views that need to be submitted to VDI.  The deletes should be processed before the submits, to ensure no duplicates.
 -workflowName:  the reflow name for the workflow that is calling this program.  (Used for tracking only)
 -workflowVersion:  the reflow name for the workflow that is calling this program.  (Used for tracking only)
 -organismAbbrev: (optional) if sourceDB is an orgDB, the organism_abbrev for that orgDB.  (Used for tracking only)
";
}

sub readPropFile {
  my ($file) = @_;

  open my $fh, '<', $file or die "Unable to open property file '$file': $!";

  my %properties;
  while (<$fh>) {
    chomp;  # Remove newline character
    next if /^\s*#/;  # Skip comments
    next unless /\S/;  # Skip empty lines
    my ($key, $value) = split /=/, $_, 2;
    $properties{$key} = $value;
  }
  my $v = $properties{dbVendor};
  die "No valid 'dbVendor' property found in file '$file'\n" unless $v eq 'Oracle' || $v eq 'Postgres';

  return \%properties;
}


sub getDbHandle {
  my ($props) = @_;
  my $dbVendor = $props->{dbVendor}; # validated to be oracle or pg
  return ($dbVendor eq 'Oracle')? getOracleDbHandle($props) : getPgDbHandle($props);
}

sub getPgDbHandle {
  my ($props) = @_;

  my $dbh = DBI->connect(
    $props->{dbiDsn},
    $props->{databaseLogin},
    $props->{databasePassword},
    { PrintError => 1, RaiseError => 0}
  ) or die "Can't connect to the database: $DBI::errstr\n";

  $dbh->do("SET ROLE GUS_W") or die ("Can't switch role to GUS_W");
  return $dbh;
}

sub getOracleDbHandle {
  my ($props) = @_;

  my $dbh = DBI->connect(
    $props->{dbiDsn},
    $props->{databaseLogin},
    $props->{databasePassword},
    { PrintError => 1, RaiseError => 0}
  ) or die "Can't connect to the database: $DBI::errstr\n";

  return $dbh;
}

=pod
Queries showing correctness of date to timestamp conversion in PG and oracle

==POSTGRES==
pfal3D7_test=> select TO_DATE('24/AUG/2023','dd/mon/yyyy'), extract(epoch from TO_DATE('24/AUG/2023','dd/mon/yyyy'));
  to_date   |  extract   
------------+------------
 2023-08-24 | 1692835200

==Oracle==
SQL> select TO_DATE('24/AUG/2023','dd/mon/yyyy') as dd, (TO_DATE('24/AUG/2023','dd/mon/yyyy') - DATE '1970-01-01')*24*60*60 as ts from dual;
DD		  TS
--------- ----------
24-AUG-23 1692835200

=cut

# return map of up-to-date tuning tables in sourceDB to their timestamp
sub getAllTuningTablesAndViews {
  my ($dbh, $dbVendor) = @_;

  # tuning name and timestamp in seconds since epoch
  my $timeSql = $dbVendor eq 'Oracle'?
    "(timestamp - DATE '1970-01-01')*24*60*60 as ts" :
    "round(extract(epoch from timestamp)) as ts";
  my $sql = "select name, $timeSql from apidb.tuningtable where status = 'up-to-date'";

  my $stmt = $dbh->prepare($sql);
  $stmt->execute();
  my $tuningMap = {};
  while (my ($name, $timestamp) = $stmt->fetchrow_array) {
    $tuningMap->{$name} = $timestamp;
  }
  return $tuningMap;
}

sub getWorkflowStmt {
  my ($workflowDbh, $workflowName, $workflowVersion, $orgAbbrev) = @_;

  my $orgAnd = $orgAbbrev? "and organism_abbrev = '$orgAbbrev'" : "";
  my $sql =
"select artifact_name, artifact_timestamp, is_complete
from apidb.WorkflowArtifactVdiId
where workflow_name = '$workflowName'
and workflow_version = '$workflowVersion'
$orgAnd
";

  return $workflowDbh->prepare($sql);
}
